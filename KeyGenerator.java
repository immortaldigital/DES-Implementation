/*
* This class takes a 56-bit key and generates 16 subkeys according to the DES standard. The order is reversed for decryption
*/

public class KeyGenerator {
	private int rNumber; // used to traverse the array of keys Ki
	private int iCount; // the current number of subkeys (incremented each time a key is added)
	private String[] subkeys; // contains the list of subkeys generated by generateSubkeys()
	private boolean reverseKeys;
	private final String BIT = "1";
	private final String COMPLEMENT = "0";
	private final int KEYLENGTH = 56;
	
	//the following permutations are standard DES permutations
	private int[] shifts = new int[]{1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1}; 
	private final int[] PC1 = new int[]{57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4};
	private final int[] PC2 = new int[]{14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32};
	
	/* @param decrypting: Will use a reverse ordering of the keys
	 * @param key: The n-bit binary digit, used to generate subkeys.
	 * @param noOfSubkeys: Corresponds to the number of rounds. Each round will have a different subkey. */
	public KeyGenerator(boolean decrypting, String key, int noOfSubkeys){
		this.iCount = 0;
		this.subkeys = new String[noOfSubkeys]; // one subkey per shift (=noOfSubkeys)
		this.reverseKeys = decrypting; 
		this.subkeys(key, noOfSubkeys);
	}

	/* Initializes the subkey array 
	 * @param mode: A 1-bit used to determine if we are encrypting or decrypting. 1 = decrypting, otherwise we are encrypting. 
	 * @param key: a n-bit binary digit.  */
	private void subkeys(String key, int noOfSubkeys){
		if(key.length() < KEYLENGTH){
			key = padded(key);
		}
		
		// depending on if we're decrypting or encrypting, start at the beginning or end of int shifts[]
		if(reverseKeys){
			this.rNumber = noOfSubkeys;
		}else{
			this.rNumber = -1;
		}

		iCount = 0;
		key = expand(key); // Argument is the KEYLENGTH bit key and expanded to insert an additional eighth bit
		key = Transposition.permute(key, PC1); //then use PC1 to return a KEYLENGTH bit key (different to the input 56 bit key)
		generateSubkeys(key, noOfSubkeys); // generate 'noOfSubkeys' subkeys
	}
	/* @param key: an n-bit key less than KEYLENGTH-bits.
	 * @return a padded KEYLENGTH-bit key */
	private String padded(String key){
		for(int i = key.length(); i < KEYLENGTH; i++){
			key += "0";
		}
		return key;
	}
	/* @param key: a KEYLENGTH-bit key
	 * @return a expanded 64-bit key */
	private String expand(String key){
		int eLength = 7;
		String padded = "";
		String sevenBits = "";

		// loop through the key and add a bit in every eighth but which is the previous 7 bits XORed
		for(int lowerBound = 0, upperBound = eLength; lowerBound < key.length() / eLength; lowerBound++, upperBound += eLength){
			sevenBits = key.substring(lowerBound * eLength, upperBound);
			// initial seven bits, but with an additional bit, return from the xor function. 
			padded += sevenBits+eighthBit(sevenBits);
		}
		return padded;
	}

	/* @param sevenBits a string containing only 1's and 0's of length 7
	 * @return the eight bit*/
	private String eighthBit(String sevenBits){
		// If there is an even number of 'BITs' return the complement of BIT
		// this method effectively takes the XOR of the seven bits
		if(count(sevenBits) % 2 == 0){
			return COMPLEMENT;	
		}else{
			return BIT;
		}
	}

	/* Determines the number of occurrences of BIT within the argument 'sevenBits'.
	 * @param sevenBits: 7-bit binary integer. 
	 * @return the count of the number of 'BIT's in the @param sevenBits*/
	private int count(String sevenBits){
		int count = 0;
		
		for(int i = 0; i < sevenBits.length() - 1; i++){ //loop through the string character by character
			if(sevenBits.substring(i, i + 1).equals(BIT)){ //compare each bit to our target char
				count++; //if they match then increase the count
			}
		}
		return count;
	}

	/* @param key: The KEYLENGTH-bit binary integer.  
	 * @param noOfSubkeys: The number of corresponding rounds. */
	private void generateSubkeys(String key, int noOfSubkeys) {
		String c = "";
		String d = "";

		for(int i = 0; i < noOfSubkeys; i++){ //loop for each subkey we need to generate
			// take the left shift of the left and right sides of the key, leftShift depends on the value of shifts[i]
			// The number of shifts stays within the shift array (i % shifts.length)
			c = leftShift(i % shifts.length, left(key));
			d = leftShift(i % shifts.length, right(key));
			key = c + d;
			add(Transposition.permute(key, PC2)); //permute our key, then add it to the array of subkeys
		}
	}

	/* @param round: the corresponding 'ith' round index in the shift array. 
	 * @param side: The text needed to have the left shift performed on.
	 * @return All bits in the text will have been shifted 'shift' number of times to the left */
	private String leftShift(int round, String side){
		int shift = shifts[round];
		String text = "";

		for(int i = 0, index = 0; i < side.length(); i++){ //loop character by character through String side
			index = (i + shift) % side.length(); //add the character located at side[i+SHIFT] where SHIFT is either 1 or 2
			text += side.substring(index, index + 1);
		}

		return text;
	}

	/* Add the @param subkey to the array of generated subkeys. 
	 * @param subkey: 48-bit binary integer*/
	private void add(String subkey){
		subkeys[iCount] = subkey;
		iCount++;
	}

	/* @return the subkey at the rNumber position in the array of subkeys. 
	 * Either we are traversing the order of subkeys from 0 -> number of subkeys, or
	 * number of subkeys -> 0.*/	
	public String subkey(){
		if(reverseKeys){
			rNumber--;
		}else{
			rNumber++;
		}
		return subkeys[rNumber];
	}

	/* @param key: KEYLENGTH-bit binary digit.
	 * @return the left half of the @param key */
	private String left(String key){ return key.substring(0, (key.length() / 2));}
	
	/* @param key: KEYLENGTH-bit binary digit. 
	 * @return the right half of the @param key */
	private String right(String key){ return key.substring((key.length() / 2), key.length());}
}
